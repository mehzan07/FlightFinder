The "Hybrid" Logic (Why you see Amadeus/Travelpayouts)
Your Python backend is likely designed to act as a Metasearch.

Amadeus & Travelpayouts (Local Search): These are called inside your function to get data immediately to show on your website (the "4 flights found" you see in the log). This allows you to show prices and times directly in your UI without sending the user away.search_flights

Travelpayouts API: Usually provides "cheapest" cached data. If it returns 0 results, it just means their cache doesn't have that specific route for that day.

2. The "Deep Link" Logic (Why it goes to Aviasales)
Even though your app finds 4 flights via Amadeus, your app cannot process credit cards or issue tickets itself (as that requires massive legal bonding).

The Redirect: When the user hits "Search" or clicks a flight, the app builds that URL for Aviasales (which is the consumer brand of Travelpayouts).

The Reason: You are using Aviasales as your Booking Engine. You find the flight details via Amadeus to show the user, but you "hand off" the user to Aviasales to actually complete the purchase so you can earn an affiliate commission.

3. Why Travelpayouts returns 0 but Amadeus returns 4?
This is a very common scenario in flight debugging:

Amadeus is a GDS (Global Distribution System). It is "Live." It talks directly to the airlines' inventory. It is highly accurate but can be expensive or limited in request counts.

Travelpayouts API often relies on Cached Data. If no one else has searched for "Stockholm to London" in the last few hours on their network, their API might return empty to save server power, whereas Amadeus will always look for a fresh seat.

Summary of the Flow
User clicks Search.

Python asks Amadeus ("What's available?") -> Amadeus says: 4 Flights.

Python asks Travelpayouts API ("What's available?") -> API says: 0 Flights.

UI shows the 4 Amadeus flights.

Form Submit triggers the logic we wrote, which builds the Aviasales URL to make sure the user can actually pay for the flight.flightFinder.js