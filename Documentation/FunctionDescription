 What Is app.py Doing?
This file is the main controller of your Flask web application. It connects everything: user login, chatbot logic, travel search, and HTML templates.


App Setup & Configuration
âœ… Environment Setup
- Loads .env variables like PORT, SECRET_KEY, and DATABASE_URL so sensitive info isnâ€™t hardcoded.
- Sets up Flask in development mode for debugging.


Flask App Initialization
app = Flask(__name__, static_folder="static")
- Creates the Flask app.
- Sets secret key and database config.
- Enables auto-reloading of templates.

Database Setup
setup_database(app)
init_models()
Initializes SQLAlchemy and creates tables if you're in development mode.


Authentication Routes
/login
- Accepts a username.
- Checks if it matches the expected one.
- Creates or updates a User in the database.
- Stores user info in session.
/logout
- Clears session and redirects to home.

ğŸ§  General Chatbot Routes
/chatbot and /chat
- Accepts user input via POST.
- Uses chatbot_response() to generate a reply.
- Returns JSON with the botâ€™s response.
/chatbot-ui
- Renders the chatbot interface (chatbot_ui.html).

âœˆï¸ Travel Chatbot Routes
These are the heart of your travel assistant.
/travel-ui
- Accepts form input like â€œI want to fly from Paris to Tokyo on Sept 1â€.
- Extracts cities and dates using extract_travel_entities().
- Converts cities to IATA codes (e.g., Paris â†’ CDG).
- Searches for flights using search_flights(...).
- Renders travel_results.html with flight options or error messages.

/travel-chat
- Similar to /travel-ui, but designed for chatbot-style interaction.
- Uses the same logic to extract info and search flights.

/results and /confirm
- Handle form submissions and flight confirmation.
- Show selected flight details in confirmation.html.

ğŸ“œ History Route
/history
- Fetches all chat messages from the database for the logged-in user.
- Filters by login time.
- Displays them in history.html.

ğŸ  Home Page
/
- Checks if user is logged in.
- If not, redirects to /login.
- If yes, sets a session ID and shows home.html.

ğŸ©º Health Check
/health
- Returns a simple JSON to confirm the app is running.

ğŸ› Debug Mode
If you're running in development:
debugpy.listen(("0.0.0.0", 5681))


- Opens a port for remote debugging.

ğŸ—ºï¸ Route Overview
At the end:
for rule in app.url_map.iter_rules():
    print(rule)


- Prints all registered routes so you can see whatâ€™s available.

ğŸ’¡ Summary: Two Chatbots in One App
|  |  |  | 
|  | /chatbot/chat |  | 
|  | /travel-ui/travel-chat |  | 



What Is extract_travel_entities()?
This function is like your chatbotâ€™s travel interpreter. When a user types something like:
â€œI want to fly from Stockholm to Tokyo from 2025-10-10 to 2025-10-17 for 1 passenger with a budget of 220 eurosâ€

â€¦it breaks that sentence into structured data your app can use:
{
  "origin": "stockholm",
  "destination": "tokyo",
  "departure_date": datetime.datetime(2025, 10, 10),
  "return_date": datetime.datetime(2025, 10, 17),
  "passengers": 1,
  "budget": 220
}
his lets your app search flights, validate dates, and show results â€” without needing the user to fill out a form.

ğŸ” What Does It Actually Do?
Hereâ€™s what it typically looks for:
|  |  |  | 
|  |  | "stockholm" | 
|  |  | "tokyo" | 
|  |  | datetime(2025, 10, 10) | 
|  |  | datetime(2025, 10, 17) | 
|  |  | 1 | 
|  |  | 220 | 


It uses regular expressions or natural language parsing to find these patterns in the userâ€™s sentence.

ğŸ§© Where Is It Used?
You call extract_travel_entities(user_input) in both:
- /travel-ui route (form-based)
- /travel-chat route (chat-based)
Right after the user submits their travel request, this function runs to pull out the key details.

ğŸ›  What Happens Next?
Once the info is extracted, your app:
- Converts cities to airport codes (city_to_iata)
- Validates the dates and budget
- Calls search_flights(...) with the structured data
- Renders travel_results.html with flight options

ğŸ§  Why Itâ€™s So Important
Without this function, your chatbot wouldnâ€™t understand natural language travel requests. Itâ€™s the bridge between human-friendly input and machine-usable data.

Would you like me to show you the full code for a clean, reliable version of extract_travel_entities() next? I can walk you through how to build or improve it.

What Does It Actually Do?
Hereâ€™s what it typically looks for:
|  |  |  | 
|  |  | "stockholm" | 
|  |  | "tokyo" | 
|  |  | datetime(2025, 10, 10) | 
|  |  | datetime(2025, 10, 17) | 
|  |  | 1 | 
|  |  | 220 | 



It uses regular expressions or natural language parsing to find these patterns in the userâ€™s sentence.


Where Is It Used?
You call extract_travel_entities(user_input) in both:
- /travel-ui route (form-based)
- /travel-chat route (chat-based)
Right after the user submits their travel request, this function runs to pull out the key details.

 What Happens Next?
Once the info is extracted, your app:
- Converts cities to airport codes (city_to_iata)
- Validates the dates and budget
- Calls search_flights(...) with the structured data
- Renders travel_results.html with flight options

ğŸ§  Why Itâ€™s So Important
Without this function, your chatbot wouldnâ€™t understand natural language travel requests. Itâ€™s the bridge between human-friendly input and machine-usable data.

Would you like me to show you the full code for a clean, reliable version of extract_travel_entities() next? I can walk you through how to build or improve it.

Why Itâ€™s So Important
Without this function, your chatbot wouldnâ€™t understand natural language travel requests. Itâ€™s the bridge between human-friendly input and machine-usable data.

What Happens When You Run app.py
- Python Interpreter Starts
VS Code launches the Python interpreter and executes app.py.
- Flask App Loads into Memory
The Flask(__name__) instance is created, and all your route definitions (@app.route(...)) are registered.
- Server Starts Listening
Flask starts a local development server (usually on http://127.0.0.1:5000) and waits for incoming HTTP requests.
- User Triggers Routes
When a user interacts with your app (via browser or chatbot), Flask matches the request to the correct route and calls the associated function

Example Flow
Letâ€™s say your app.py has this route:
@app.route('/travel-chat', methods=['POST'])
def travel_chat():
    user_input = request.form['user_input']
    entities = extract_travel_entities(user_input)
    # ... more logic ...
    Hereâ€™s how it plays out:
- You run app.py â†’ Flask loads and starts listening.
- A user sends a message â†’ /travel-chat route is triggered.
- Flask calls travel_chat() â†’ which calls extract_travel_entities() â†’ and so on.
So yes â€” once app.py is running, all your functions are loaded and ready to be called when needed.


Why Two Routes: /travel-ui vs /travel-chat
These two routes serve different user experiences:
|  |  |  | 
| /travel-ui |  |  | 
| /travel-chat |  |  | 


ğŸ”¹ /travel-ui
- This is for users who prefer structured input.
- They select origin, destination, dates, etc. from dropdowns or calendars.
- When they submit the form, the app processes the data directly.

ğŸ”¹ /travel-chat
- This is for users who want to â€œtalkâ€ to the app.
- They type something like:
- â€œI want to fly from Stockholm to Tokyo next October for 1 personâ€
- The app uses extract_travel_entities() to parse that sentence into usable data.

Which One Starts First?
That depends on how the user enters the app:
- If your homepage or landing page links to /travel-ui, then thatâ€™s what loads first.
- If the chatbot interface is the default, then /travel-chat is triggered first.
So technically, neither route is â€œautomaticallyâ€ started â€” Flask waits for the user to interact, and then calls the route based on what they click or submit.

ğŸ§  Developer Tip
If you want to control which route is the default, you can set up your root route / like this:
@app.route('/')
def home():
    return redirect(url_for('travel_ui'))  # or 'travel_chat'


That way, visiting http://localhost:5000/ will send users to the experience you want them to start with.


 form-based interface, the route /travel-ui is the one being actively used. Thatâ€™s where users manually enter their travel details (origin, destination, dates, budget, etc.), and your app processes that structured input to find flights and prices.
The /travel-chat route, on the other hand, is designed for natural language input â€” like when a user types:
â€œI want to fly from Stockholm to Tokyo next October for 1 personâ€

we havenâ€™t built or connected the chatbot interface yet, then  â€” /travel-chat is not being used at the moment. Itâ€™s just sitting there, waiting for its moment to shine ğŸ˜„







